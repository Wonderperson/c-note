成员函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前。
**在类体中和类体外定义成员函数的区别**

> 在类体中和类体外定义成员函数是有区别的：在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。当然，在类体内部定义的函数也可以加 inline 关键字，但这是多余的，因为类体内部定义的函数默认就是内联函数。
> 
> 内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是一种良好的编程习惯，实际开发中大家也是这样做的。

**内联函数inline**
引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：

1. 在内联函数内不允许使用循环语句和开关语句；
2. 内联函数的定义必须出现在内联函数第一次调用之前；
3. 类结构中所在的类说明内部定义的函数是内联函数。

* C++ 中的 public、private、protected 只能修饰类的成员，不能修饰类，C++中的类没有共有私有之分。

> 在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是private，都是可以互相访问的，没有访问权限的限制。
> 
> 在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问private、protected 属性的成员。

    1. //在栈上创建对象
     2.  Student  stu;
     3.  stu.setname("小明");
     4.  stu.setage(15);
     5.  stu.setscore(92.5f);
     6.  stu.show();
    
     7.  //在堆上创建对象
     8.  Student  *pstu = new Student;
     9.  pstu -&gt; setname("李华");
     10.  pstu -&gt; setage(16);
     11.  pstu -&gt; setscore(96);
     12.  pstu -&gt; show();
    
     13.  return 0;
     14.  }

**构造函数**
 * 一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。
*  构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。
* 调用没有参数的构造函数也可以省略括号

**C++构造函数初始化列表**
构造函数初始化列表**
* 使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。

* 成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关

* 类对象在栈上分配内存，成员变量的初始值是不确定的。

> 示例一

</blockquote>
<preStudent::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
//TODO:
  }
</code></pre>
<blockquote>
<p>示例二</p>
</blockquote>
<pre><code>Student::Student(char *name, int age, float score): m_name(name){
  m_age = age;
  m_score = score;
  }
</code></pre>

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTM4Mjc0MTI4Nl19
-->